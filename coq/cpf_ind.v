(**
Rainbow, a termination proof certification tool

See the COPYRIGHTS and LICENSE files.

- Kim Quyen LY, 2011-04-06

* Re-define the induction principle for CPF

*)

Set Implicit Arguments.

Require Import EqUtil String List ListDec ZUtil LogicUtil BoolUtil
  cpf.

(***********************************************************************)
(** Re-define the induction principle automatically generated by Coq
   for the inductive type. *)

(** Induction principle on symbol. *)

Section new_symbol_rect.

  Variables (P : symbol -> Type) (Q : list symbol -> Type)
    (Hname    : forall n,    P (Symbol_name n))
    (Hsharp   : forall f,    P f -> P (Symbol_sharp f))
    (HnumLab  : forall f zs, P f -> P (Symbol_labeledSymbol f (Label_numberLabel zs)))
    (HsymbLab : forall f fs, P f -> Q fs ->
                             P (Symbol_labeledSymbol f (Label_symbolLabel fs)))
    (Hnil     : Q nil)
    (Hcons    : forall f fs, P f -> Q fs -> Q (f :: fs)).

  Fixpoint new_symbol_rect f :=
    match f as f return P f with
      | Symbol_name n                                  => Hname n
      | Symbol_sharp f'                                => Hsharp (new_symbol_rect f')
      | Symbol_labeledSymbol f' (Label_numberLabel zs) => HnumLab zs (new_symbol_rect f')
      | Symbol_labeledSymbol f' (Label_symbolLabel fs) =>
        let fix new_symbol_rect_list gs :=
          match gs as gs return Q gs with
            | nil      => Hnil
            | g :: gs' => Hcons (new_symbol_rect g) (new_symbol_rect_list gs')
          end
          in HsymbLab (new_symbol_rect f') (new_symbol_rect_list fs)
    end.

End new_symbol_rect.

Section symbol_ind_In.

  Variables (P : symbol -> Prop)
    (Hname    : forall n,    P (Symbol_name n))
    (Hsharp   : forall f,    P f -> P (Symbol_sharp f))
    (HnumLab  : forall f zs, P f -> P (Symbol_labeledSymbol f (Label_numberLabel zs)))
    (HsymbLab : forall f fs, P f -> (forall f, In f fs -> P f) ->
                             P (Symbol_labeledSymbol f (Label_symbolLabel fs))).

  Lemma symbol_ind_In : forall f, P f.

  Proof.
    apply new_symbol_rect with
      (Q := fun fs => forall f, In f fs -> P f); auto.
    intros. contradiction.
    simpl. intros. destruct H1. subst. apply H. firstorder.
  Qed.

End symbol_ind_In.

(***********************************************************************)
(** Boolean equality of symbol. *)

Definition beq_string := beq_dec string_dec.

Fixpoint beq_symbol f g :=
  match f, g with
    | Symbol_name n,             Symbol_name m             => beq_string n m
    | Symbol_sharp f',           Symbol_sharp g'           => beq_symbol f' g'
    | Symbol_labeledSymbol f' l, Symbol_labeledSymbol g' m => beq_symbol f' g' &&
                                                              beq_label l m
    | _, _                                                 => false
  end

with beq_label l m :=
  match l, m with
    | Label_numberLabel xs, Label_numberLabel ys => beq_list Neqb xs ys
    | Label_symbolLabel fs, Label_symbolLabel gs => beq_list beq_symbol fs gs
    | _, _                                       => false
  end.

Lemma beq_symbol_ok : forall f g, beq_symbol f g = true <-> f = g.
                                 
Proof.
intro f; pattern f; apply new_symbol_rect with
  (Q := fun fs => forall gs, beq_list beq_symbol fs gs = true <-> fs = gs);
  simpl.
(* name *)
destruct g.
unfold beq_string. rewrite beq_dec_ok. intuition.
subst. refl. inversion H. refl.
split; intro. discr. discr.
split; intro. discr. discr.
(* sharp *)
destruct g.
split; intro. discr. discr.
rewrite H; intuition. subst. refl. inversion H0; refl.
intuition; discr.
(* LabeledSymbol *)
destruct g.
split. intro. discr. discr.
split. intro. discr. discr.
(* Label_numberlabel *)
rewrite andb_eq, H. destruct l.
rewrite beq_list_ok. 2: apply Neqb_eq. split. intros. destruct H0. 
subst. refl. intros. split. inversion H0. refl. inversion H0. subst. refl.
split. intros. destruct H0. discr.
intros. split. discr. discr.
(* Label_symbolLabel *)
destruct g.
split. intro. discr. discr.
split. intro. discr. discr.
rewrite andb_eq, H. destruct l.
split. intro. destruct H1. discr. intros. split. discr.
discr. 
rewrite H0.
split. intros. destruct H1.
subst. refl. intros. split. inversion H1. refl. inversion H1. refl.
(* nil *)
destruct gs. tauto. split. intros. discr.
intros. discr.
(* cons *)
destruct gs. split. intros. discr.
intros. discr.
rewrite andb_eq, H, H0. 
split. intros. destruct H1.
subst. refl. intros. split. inversion H1. refl. inversion H1. refl.
Qed.

(***********************************************************************)
(** Induction principle on term. *)

Section new_term_rect.

  Variables (P : term -> Type) (Q : list term -> Type)
    (Hvar : forall x,            P (Term_var x))
    (Hfun : forall f ts, Q ts -> P (Term_funapp f ts))
    (Hnil :              Q nil)
    (Hcons : forall t ts,        P t -> Q ts -> Q (t :: ts)).
  
  Fixpoint new_term_rect t :=
    match t as t return P t with
      | Term_var x       => Hvar x
      | Term_funapp f ts =>
        let fix new_term_rects ts :=
          match ts as ts return Q ts with
            | nil     => Hnil
            | u :: us => Hcons (new_term_rect u) (new_term_rects us)
          end
          in Hfun f (new_term_rects ts)
    end.

End new_term_rect.

(** Boolean equality of term. *)

Fixpoint beq_term t u :=
  match t, u with
    | Term_var x,       Term_var y       => beq_string x y
    | Term_funapp f ts, Term_funapp g gs => beq_symbol f g && beq_list beq_term ts gs
    | _, _                               => false
  end.

Lemma beq_term_ok : forall t u, beq_term t u = true <-> t = u.

Proof.
  intro t; pattern t; apply new_term_rect with (Q := fun fs =>
    forall gs, beq_list beq_term fs gs = true <-> fs = gs); simpl.
  (* var *)
  destruct u; split; intros; try discr.
  unfold beq_string in H.
  rewrite beq_dec_ok in H. 
  subst. refl. unfold beq_string. rewrite beq_dec_ok. inversion H. refl.  
  (* funapp *)
  destruct u; split; intros; try discr. 
  rewrite andb_eq in H0. destruct H0.
  rewrite H in H1. rewrite beq_symbol_ok in H0. subst. auto.
  rewrite andb_eq. split.
  apply beq_symbol_ok. inversion H0. refl.
  rewrite H. inversion H0. auto.
  (* nil *)
  destruct gs; split; intros; try discr; auto.
  (* cons *)
  destruct gs; split; intros; try discr.
  rewrite andb_eq in H1. destruct H1.
  rewrite H0 in H2. rewrite H in H1. subst. auto.
  rewrite andb_eq. split.
  rewrite H. inversion H1. refl.
  rewrite H0. inversion H1. refl.
Qed.

(***********************************************************************)
(** Boolean equality of rule. *)

Definition beq_rule (r1 r2: rule) :=
  match r1, r2 with
    | (a, b), (c, d) => beq_term a c && beq_term b d
  end.

Lemma beq_rule_ok : forall l r, beq_rule l r = true <-> l = r.
  
Proof.
  destruct l as [l1 l2]. destruct r as [r1 r2]. unfold beq_rule. 
  simpl.
  rewrite andb_eq. repeat rewrite beq_term_ok. split.
  intros. destruct H. 
  subst. refl. intro. inversion H. auto.
Qed.

Definition brule (f : term -> term -> bool) (r: rule) :=
  match r with
    | (a, b) => f a b
  end.

(** Boolean equality of number. *)

Fixpoint beq_number n1 n2 :=
  match n1, n2 with
    | Number_integer x,    Number_integer y    => beq_Z x y
    | Number_rational m n, Number_rational o p => beq_Z m o && beq_pos n p
    | _, _                                     => false
  end.

Lemma beq_number_ok : forall n m, beq_number n m = true <-> n = m.

Proof.
unfold beq_number.
(* integer *)
destruct n, m; split; intros; try discr.
rewrite beq_Z_ok in H. subst. auto.
rewrite beq_Z_ok. inversion H. auto.
(* rational *)
rewrite andb_eq in H. rewrite beq_Z_ok in H.
destruct H. rewrite beq_pos_ok in H0. subst. auto.
rewrite andb_eq. split. rewrite beq_Z_ok. inversion H.
auto.
rewrite beq_pos_ok. inversion H. auto.
Qed.

(***********************************************************************)
(** Induction principle on coefficient. *)

Section new_coef_rect.

  Variables (P: coefficient -> Type) (Q: list coefficient -> Type)
    (R        : list (list coefficient) -> Type)
    (Hnum     : forall n, P (Coefficient_number n))
    (Hminus   :           P Coefficient_minusInfinity)
    (Hplus    :           P Coefficient_plusInfinity)
    (Hvec     : forall v, Q v -> P (Coefficient_vector (Vector_vector v)))
    (Hmat     : forall m, R m -> P (Coefficient_matrix (Matrix_matrix m)))
    (Hnil     : Q nil)
    (Hmatnil  : R nil)    
    (Hmatcons : forall c cs, Q c -> R cs -> R (c :: cs))
    (Hcons    : forall c cs, P c -> Q cs -> Q (c :: cs)).

  Fixpoint new_coef_rect c :=
    let fix new_coef_rect_vec cs :=
      match cs as cs return Q cs with
        | nil      => Hnil
        | c :: cs' => Hcons (new_coef_rect c) (new_coef_rect_vec cs')
      end in
      let fix new_coef_rect_mat vs :=
        match vs as vs return R vs with
          | nil      => Hmatnil
          | c :: vs' => Hmatcons (new_coef_rect_vec c) (new_coef_rect_mat vs')
        end in
        match c as c return P c with
          | Coefficient_number n                  => Hnum n
          | Coefficient_minusInfinity             => Hminus
          | Coefficient_plusInfinity              => Hplus
          | Coefficient_vector (Vector_vector cs) => Hvec (new_coef_rect_vec cs)
          | Coefficient_matrix (Matrix_matrix vs) => Hmat (new_coef_rect_mat vs)
        end.

End new_coef_rect.

(** Boolean equality of coefficient. *)

Fixpoint beq_coef c1 c2 :=
  match c1, c2 with
    | Coefficient_number n,      Coefficient_number m      => beq_number n m
    | Coefficient_minusInfinity, Coefficient_minusInfinity => true
    | Coefficient_plusInfinity,  Coefficient_plusInfinity  => true
    | Coefficient_vector x,      Coefficient_vector y      => beq_vec x y
    | Coefficient_matrix n,      Coefficient_matrix m      => beq_mat n m
    | _, _                                                 => false
  end
  
with beq_vec x y :=
  match x, y with
    | Vector_vector x, Vector_vector y => beq_list beq_coef x y
  end

with beq_mat m n :=
  match m, n with
    | Matrix_matrix m, Matrix_matrix n =>
      let beq_vec m n := beq_list beq_coef m n in
        beq_list beq_vec m n 
  end.

Lemma beq_coef_ok : forall f g, beq_coef f g = true <-> f = g.
Proof.
  intro f; pattern f; apply new_coef_rect with
    (Q := fun u => forall v, beq_list beq_coef u v = true <-> u = v)
    (R := fun m => forall n,
      let beq_vec u v := beq_list beq_coef u v in
        beq_list beq_vec m n = true <-> m = n); simpl.
  (* number *)
  destruct g; split; intros; try discr.
  rewrite beq_number_ok in H. subst. refl.
  auto.  
  rewrite beq_number_ok. inversion H. refl.
  (* minusInfinity *)
  destruct g; split; intros; try discr; auto.
  (* plusInfinity *)
  destruct g; split; intros; try discr; auto.
  (* vector *)
  destruct g; split; intros; try discr; auto.
  destruct v.
  destruct v0; try discr.
  rewrite H in H0. subst. auto.
  destruct v0; try discr.
  rewrite H in H0. subst. auto.
  destruct v0; try discr.
  rewrite H. inversion H0. auto.
  (* matrix *)
  destruct g; split; intros; try discr.
  destruct m0. rewrite H in H0. subst. auto.
  destruct m0; try discr.
  rewrite H. inversion H0. auto.
  (* vec nil *)
  destruct v; split; intros; try discr; auto.
  (* mat nil *)
  destruct n; split; intros; try discr; auto.
  (* mat cons *)
  intros v vs hv hvs. 
  destruct n; split; intros; try discr.
  destruct l; try discr.
  rewrite andb_eq in H. destruct H.
  rewrite hv in H.
  rewrite (hvs n) in H0. inversion H0. subst. refl.
  rewrite andb_eq in H. destruct H.
  rewrite hv in H. rewrite (hvs n) in H0. inversion H0. subst. auto.
  rewrite andb_eq. rewrite hv. rewrite (hvs n). inversion H. auto.
 (* vec cons *)
  intros c cs hc hcs. 
  destruct v; split; intros; try discr.
  rewrite andb_eq in H. destruct H. rewrite hc in H.
  rewrite (hcs v) in H0. inversion H0. subst. auto.
  rewrite andb_eq. rewrite hc. rewrite (hcs v). inversion H. auto.
Qed.

(***********************************************************************)
(** Induction principle on polynomial. *)

Section new_polynomial_rect.

  Variables (P : polynomial -> Type) (Q : list polynomial -> Type)
    (Hcoef     : forall c, P (Polynomial_coefficient c))
    (Hvar      : forall x, P (Polynomial_variable x))
    (Hsum      : forall l, Q l -> P (Polynomial_sum l))
    (Hprod     : forall l, Q l -> P (Polynomial_product l))
    (Hmax      : forall l, Q l -> P (Polynomial_max l))
    (Hmin      : forall l, Q l -> P (Polynomial_min l))
    (Hnil      : Q nil)
    (Hcons     : forall p l, P p -> Q l -> Q (p :: l)).

  Fixpoint new_polynomial_rect p       :=
    let fix new_polynomial_rect_list l :=
      match l as l return Q l with
        | nil     => Hnil
        | p :: l' => Hcons (new_polynomial_rect p) (new_polynomial_rect_list l')
      end in
    match p as p return P p with
      | Polynomial_coefficient c => Hcoef c
      | Polynomial_variable x    => Hvar x
      | Polynomial_sum l         => Hsum (new_polynomial_rect_list l)
      | Polynomial_product l     => Hprod (new_polynomial_rect_list l)
      | Polynomial_max l         => Hmax (new_polynomial_rect_list l)
      | Polynomial_min l         => Hmin (new_polynomial_rect_list l)
    end.

End new_polynomial_rect.

(** Boolean equality of polynomial. *)

Fixpoint beq_polynomial p q :=
  match p, q with
    | Polynomial_coefficient c, Polynomial_coefficient d => beq_coef c d
    | Polynomial_variable x,    Polynomial_variable y    => beq_pos x y
    | Polynomial_sum l,         Polynomial_sum m         => beq_list beq_polynomial l m
    | Polynomial_product l,     Polynomial_product m     => beq_list beq_polynomial l m
    | Polynomial_max l,         Polynomial_max m         => beq_list beq_polynomial l m
    | Polynomial_min l,         Polynomial_min m         => beq_list beq_polynomial l m
    | _, _                                               => false
  end.

Lemma beq_poly_ok : forall p q, beq_polynomial p q = true <-> p = q.

Proof.
  intro p; pattern p; apply new_polynomial_rect with
    (Q := fun l => forall m, beq_list beq_polynomial l m = true <-> l = m);
    simpl.
  (* coef *)
  destruct q; try rewrite beq_coef_ok; split; intros; try discr.
  rewrite H. auto.
  inversion H. auto.
  (* variable *)
  destruct q; try rewrite beq_pos_ok; split; intros; try discr.
  rewrite H. auto. inversion H. auto.
  (* sum *)
  destruct q; split; intros; try discr.
  rewrite H in H0. subst. auto.
  rewrite H. inversion H0. auto.
  (* product *)
  destruct q; split; intros; try discr.
  rewrite H in H0. subst. auto.
  rewrite H. inversion H0. auto.
  (* max *)
  destruct q; split; intros; try discr.
  rewrite H in H0. subst. auto.
  rewrite H. inversion H0. auto.
  (* min *)
  destruct q; split; intros; try discr.
  rewrite H in H0. subst. auto.
  rewrite H. inversion H0. auto.
  (* nil *)
  destruct m; split; intros; try discr; auto.
  (* cons *)
  destruct m; try rewrite andb_eq; split; intros; try discr.
  destruct H1. rewrite H in H1. rewrite H0 in H2. subst. auto.
  split.
  rewrite H. inversion H1. auto.
  rewrite H0. inversion H1. auto.
Qed.